# -*- coding: utf-8 -*-
"""zigzag_crawling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K1W22aPhmlmcritqVcDG7PMtLSoRb8aE
"""



# 필요한 라이브러리 임포트
import pandas as pd  # 데이터프레임 작업을 위한 pandas 라이브러리
import time  # 대기 시간을 설정하기 위한 time 모듈
import csv  # CSV 파일을 처리하기 위한 csv 모듈
from selenium import webdriver  # Selenium을 통해 브라우저를 제어하기 위한 모듈
from webdriver_manager.chrome import ChromeDriverManager  # 드라이버 자동 설치를 위한 모듈
from selenium.webdriver.chrome.service import Service  # ChromeDriver 서비스를 초기화하기 위한 모듈
from selenium.webdriver.common.by import By  # 요소를 찾기 위한 검색 조건 정의 모듈
from selenium.webdriver.common.action_chains import ActionChains  # 액션 체인을 사용한 복잡한 동작 구현 모듈
from selenium.webdriver.support import expected_conditions as EC  # 특정 조건 대기 모듈
from selenium.webdriver.support.ui import WebDriverWait  # 명시적 대기를 위한 모듈
from selenium.webdriver.common.keys import Keys  # 키 입력 동작 구현을 위한 모듈

# 페이지를 스크롤하여 리뷰를 로드하는 함수
def scroll_to_load_reviews(driver, max_reviews=2100):
    review_ids = set()  # 중복 리뷰 방지를 위한 집합 생성
    while len(review_ids) < max_reviews:  # 목표 리뷰 개수에 도달할 때까지 반복
        driver.find_element(By.TAG_NAME, "body").send_keys(Keys.END)  # 페이지를 아래로 스크롤
        time.sleep(1)  # 리뷰가 로드될 시간을 확보
        reviews = driver.find_elements(By.CSS_SELECTOR, "#__next > div.zds-themes.light-theme > div > div > div.css-xk426o.eebc9th5 > div > div")  # 리뷰 요소를 모두 찾음
        for num, review in enumerate(reviews, start=1):  # 리뷰 요소를 반복하며
            try:
                review_id = driver.find_element(By.CSS_SELECTOR,  # 리뷰의 고유 ID를 추출
                    f"#__next > div.zds-themes.light-theme > div > div > div.css-xk426o.eebc9th5 > div > div:nth-child({num}) > div.css-vbvoj0.e13bai5o0 > div.css-1ecn1de.e13bai5o0 > div.css-o3enub.e1umgzx81 > div.css-4ku0lv.e13bai5o0 > p").text
                if review_id:
                    review_ids.add(review_id)  # 리뷰 ID를 집합에 추가
            except Exception:
                continue  # 오류 발생 시 넘어감
        print(f"리뷰 불러오기: {len(review_ids)}/{max_reviews}", end="\r")  # 진행 상황 출력
    print(f"\n총 {len(review_ids)} 리뷰 불러오기 성공!")  # 최종 리뷰 개수 출력

# '더보기' 버튼을 클릭하여 추가 리뷰를 불러오는 함수
def click_more_buttons(driver, max_reviews, start_num=1):
    for num in range(start_num, max_reviews + 1):  # 주어진 리뷰 번호 범위 동안 반복
        try:
            more_button = driver.find_element(By.CSS_SELECTOR,  # '더보기' 버튼을 찾음
                f"div:nth-child({num}) > div.css-vbvoj0.e13bai5o0 > div:nth-child(3) > span > p")
            if more_button.is_displayed():  # 버튼이 화면에 보이면
                more_button.click()  # 버튼 클릭
                time.sleep(0.5)  # 버튼 클릭 후 대기
                print(f"더보기 클릭 중 {num}")  # 진행 상황 출력
        except Exception:
            pass  # 버튼이 없거나 클릭 실패 시 넘어감

# 리뷰 데이터를 수집하는 함수
def crawl_reviews(driver, product_id, max_reviews=2100, start_num=1):
    reviews_data = []  # 수집된 리뷰 데이터를 저장할 리스트
    for num in range(start_num, max_reviews + 1):  # 주어진 리뷰 번호 범위 동안 반복
        try:
            # 리뷰 데이터 초기화
            reviewer_id = ""
            reviewer_grade = ""
            review_date = ""
            option1 = ""
            option2 = ""
            size_info = ""
            quality = ""
            color_info = ""
            height = ""
            weight = ""
            size = ""
            review_content = ""
            product_review = ""

            # 각 데이터 필드 추출 시도
            try:
                reviewer_id = driver.find_element(By.CSS_SELECTOR,  # 리뷰어 ID 추출
                    f"div:nth-child({num}) > div.css-vbvoj0.e13bai5o0 > div.css-1ecn1de.e13bai5o0 > div.css-o3enub.e1umgzx81 > div.css-4ku0lv.e13bai5o0 > p").text
            except Exception:
                pass

            try:
                reviewer_grade = driver.find_element(By.CSS_SELECTOR,  # 리뷰어 등급 추출
                    f"div:nth-child({num}) > div.css-vbvoj0.e13bai5o0 > div.css-1ecn1de.e13bai5o0 > div.css-o3enub.e1umgzx81 > div.css-4ku0lv.e13bai5o0 > span").text
            except Exception:
                pass

            try:
                review_date = driver.find_element(By.CSS_SELECTOR,  # 작성 날짜 추출
                    f"div:nth-child({num}) > div.css-vbvoj0.e13bai5o0 > div.css-1ecn1de.e13bai5o0 > div.css-u4mbk0.eimmef70 > div.css-1xqlji6.eimmef70 > span.zds4_s96ru86.zds4_s96ru81c").text
            except Exception:
                pass

            # 기타 리뷰 데이터를 같은 방식으로 추출
            # 생략된 부분은 동일한 CSS 선택자 방식과 구조를 따름

            reviews_data.append({  # 수집된 데이터를 딕셔너리 형태로 리스트에 저장
                "유저 ID": reviewer_id,
                "리뷰어 등급": reviewer_grade,
                "작성 날짜": review_date,
                "옵션1": option1,
                "옵션2": option2,
                "선택 사이즈": size_info,
                "퀄리티": quality,
                "색감": color_info,
                "고객 신장": height,
                "고객 중량": weight,
                "고객 사이즈": size,
                "리뷰 내용": review_content,
                "상품평": product_review
            })

            print(f"{num}/{max_reviews} 리뷰 수집 성공", end="\r")  # 진행 상황 출력
        except Exception as e:
            continue  # 오류 발생 시 현재 리뷰를 건너뜀
    return reviews_data  # 수집된 리뷰 데이터를 반환

# 수집된 리뷰 데이터를 CSV 파일로 저장하는 함수
def save_to_csv(data, product_id):
    filename = f"reviews_{product_id}.csv"  # 파일명 설정
    df = pd.DataFrame(data)  # 데이터프레임으로 변환
    df.to_csv(filename, index=False, encoding="utf-8-sig")  # CSV 파일 저장
    print(f"상품 ID {product_id}의 데이터를 '{filename}'에 저장했습니다.")  # 저장 완료 메시지 출력

# 메인 실행 코드
if __name__ == "__main__":
    # product_ids = ["131506009", "114626733","147921597", ...]  # 수집할 상품 ID 목록
    product_ids = ["131506009"]  # 수집할 상품 ID 목록

    max_reviews = 2100  # 최대 리뷰 수

    for product_id in product_ids:  # 각 상품 ID에 대해 반복
        print(f"\n=== 상품 ID {product_id} 리뷰 수집 시작 ===")
        driver = None

        try:
            # 웹드라이버 초기화 및 페이지 접속
            driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
            driver.get(f"https://zigzag.kr/review/list/{product_id}")
            time.sleep(3)  # 페이지 로드 대기

            scroll_to_load_reviews(driver, max_reviews)  # 리뷰 스크롤 로드
            click_more_buttons(driver, max_reviews)  # '더보기' 버튼 클릭
            reviews = crawl_reviews(driver, product_id, max_reviews)  # 리뷰 데이터 수집
            save_to_csv(reviews, product_id)  # 데이터 저장

        except Exception as e:
            print(f"오류 발생: {e}")  # 오류 발생 시 메시지 출력
        finally:
            if driver:  # 드라이버 종료
                driver.quit()